<!--
WebGL Water
https://madebyevan.com/webgl-water/

Copyright 2011 Evan Wallace
Released under the MIT license
-->

<!DOCTYPE html>
<html><head>
  <meta charset="utf8">
  <title>WebGL Water</title>
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
  <!-- Embedded GLSL shaders (moved from JS files) -->
  <script id="water-vertex" type="x-shader/x-vertex">
    varying vec2 coord;
    void main() {
      coord = gl_Vertex.xy * 0.5 + 0.5;
      gl_Position = vec4(gl_Vertex.xyz, 1.0);
    }
  </script>

  <script id="water-drop-fragment" type="x-shader/x-fragment">
    const float PI = 3.141592653589793;
    uniform sampler2D texture;
    uniform vec2 center;
    uniform float radius;
    uniform float strength;
    varying vec2 coord;
    void main() {
      vec4 info = texture2D(texture, coord);
      float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);
      drop = 0.5 - cos(drop * PI) * 0.5;
      info.r += drop * strength;
      gl_FragColor = info;
    }
  </script>

  <script id="water-update-fragment" type="x-shader/x-fragment">
    uniform sampler2D texture;
    uniform vec2 delta;
    varying vec2 coord;
    void main() {
      vec4 info = texture2D(texture, coord);
      vec2 dx = vec2(delta.x, 0.0);
      vec2 dy = vec2(0.0, delta.y);
      float average = (
        texture2D(texture, coord - dx).r +
        texture2D(texture, coord - dy).r +
        texture2D(texture, coord + dx).r +
        texture2D(texture, coord + dy).r
      ) * 0.25;
      info.g += (average - info.r) * 2.0;
      info.g *= 0.99;
      info.r += info.g;
      gl_FragColor = info;
    }
  </script>

  <script id="water-normal-fragment" type="x-shader/x-fragment">
    uniform sampler2D texture;
    uniform vec2 delta;
    varying vec2 coord;
    void main() {
      vec4 info = texture2D(texture, coord);
      vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);
      vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);
      info.ba = normalize(cross(dy, dx)).xz;
      gl_FragColor = info;
    }
  </script>

  <script id="helper-functions" type="x-shader/x-fragment">
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    const vec3 abovewaterColor = vec3(0.97, 0.985, 1.0);
    const vec3 underwaterColor = vec3(0.97, 0.985, 1.0);
    const float poolHeight = 0.5;
    uniform vec3 light;
    uniform vec3 sphereCenter;
    uniform float sphereRadius;
    uniform sampler2D tiles;
    uniform sampler2D causticTex;
    uniform sampler2D water;

    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
      vec3 tMin = (cubeMin - origin) / ray;
      vec3 tMax = (cubeMax - origin) / ray;
      vec3 t1 = min(tMin, tMax);
      vec3 t2 = max(tMin, tMax);
      float tNear = max(max(t1.x, t1.y), t1.z);
      float tFar = min(min(t2.x, t2.y), t2.z);
      return vec2(tNear, tFar);
    }

    float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
      vec3 toSphere = origin - sphereCenter;
      float a = dot(ray, ray);
      float b = 2.0 * dot(toSphere, ray);
      float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;
      float discriminant = b*b - 4.0*a*c;
      if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.0) return t;
      }
      return 1.0e6;
    }

    vec3 getSphereColor(vec3 point) {
      vec3 color = vec3(0.85);
      vec3 sphereNormal = (point - sphereCenter) / sphereRadius;
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.15;
      vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
      if (point.y < info.r) {
        vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
        diffuse += caustic.r * 0.3;
      }
      color += diffuse;
      return color;
    }

    vec3 getWallColor(vec3 point) {
      float ambient = 0.85;
      vec3 wallColor;
      vec3 normal;
      if (abs(point.x) > 0.999) {
        wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;
        normal = vec3(-point.x, 0.0, 0.0);
      } else if (abs(point.z) > 0.999) {
        wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;
        normal = vec3(0.0, 0.0, -point.z);
      } else {
        wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;
        normal = vec3(0.0, 1.0, 0.0);
      }
      vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(refractedLight, normal)) * 0.15;
      vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
      if (point.y < info.r) {
        vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
        diffuse += caustic.r * 0.3 * caustic.g;
      }
      float scale = ambient + diffuse;
      return wallColor * scale;
    }
  </script>

  <script id="water-surface-vertex" type="x-shader/x-vertex">
    uniform sampler2D water;
    varying vec3 position;
    void main() {
      vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);
      position = gl_Vertex.xzy;
      position.y += info.r;
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);
    }
  </script>

  <script id="water-surface-abovewater-fragment" type="x-shader/x-fragment">
    uniform vec3 eye;
    varying vec3 position;
    uniform samplerCube sky;
    vec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
      vec3 color;
      float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);
      if (q < 1.0e6) {
        color = getSphereColor(origin + ray * q);
      } else if (ray.y < 0.0) {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        color = getWallColor(origin + ray * t.y);
      } else {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        vec3 hit = origin + ray * t.y;
        if (hit.y < 2.0 / 12.0) {
          color = getWallColor(hit);
        } else {
          color = textureCube(sky, ray).rgb;
          color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
        }
      }
      if (ray.y < 0.0) color *= abovewaterColor;
      return color;
    }
    void main() {
      vec2 coord = position.xz * 0.5 + 0.5;
      vec4 info = texture2D(water, coord);
      for (int i = 0; i < 5; i++) {
        coord += info.ba * 0.005;
        info = texture2D(water, coord);
      }
      vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
      vec3 incomingRay = normalize(position - eye);
      vec3 reflectedRay = reflect(incomingRay, normal);
      vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);
      float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));
      vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, abovewaterColor);
      vec3 refractedColor = getSurfaceRayColor(position, refractedRay, abovewaterColor);
      gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);
    }
  </script>

  <script id="water-surface-underwater-fragment" type="x-shader/x-fragment">
    uniform vec3 eye;
    varying vec3 position;
    uniform samplerCube sky;
    vec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
      vec3 color;
      float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);
      if (q < 1.0e6) {
        color = getSphereColor(origin + ray * q);
      } else if (ray.y < 0.0) {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        color = getWallColor(origin + ray * t.y);
      } else {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        vec3 hit = origin + ray * t.y;
        if (hit.y < 2.0 / 12.0) {
          color = getWallColor(hit);
        } else {
          color = textureCube(sky, ray).rgb;
          color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
        }
      }
      if (ray.y < 0.0) color *= waterColor;
      return color;
    }
    void main() {
      vec2 coord = position.xz * 0.5 + 0.5;
      vec4 info = texture2D(water, coord);
      for (int i = 0; i < 5; i++) {
        coord += info.ba * 0.005;
        info = texture2D(water, coord);
      }
      vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
      normal = -normal;
      vec3 incomingRay = normalize(position - eye);
      vec3 reflectedRay = reflect(incomingRay, normal);
      vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);
      float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));
      vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, underwaterColor);
      vec3 refractedColor = getSurfaceRayColor(position, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);
      gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);
    }
  </script>

  <script id="cube-vertex" type="x-shader/x-vertex">
    varying vec3 position;
    void main() {
      position = gl_Vertex.xyz;
      position.y = ((1.0 - position.y) * (7.0 / 12.0) - 1.0) * poolHeight;
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);
    }
  </script>

  <script id="cube-fragment" type="x-shader/x-fragment">
    varying vec3 position;
    void main() {
      gl_FragColor = vec4(getWallColor(position), 1.0);
      vec4 info = texture2D(water, position.xz * 0.5 + 0.5);
      if (position.y < info.r) {
        gl_FragColor.rgb *= underwaterColor * 1.2;
      }
    }
  </script>

  <script id="caustics-vertex" type="x-shader/x-vertex">
    varying vec3 oldPos;
    varying vec3 newPos;
    varying vec3 ray;
    vec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {
      vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      origin += ray * tcube.y;
      float tplane = (-origin.y - 1.0) / refractedLight.y;
      return origin + refractedLight * tplane;
    }
    void main() {
      vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);
      info.ba *= 0.5;
      vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      ray = refract(-light, normal, IOR_AIR / IOR_WATER);
      oldPos = project(gl_Vertex.xzy, refractedLight, refractedLight);
      newPos = project(gl_Vertex.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);
      gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);
    }
  </script>

  <script id="caustics-fragment" type="x-shader/x-fragment">
    varying vec3 oldPos;
    varying vec3 newPos;
    varying vec3 ray;
    void main() {
      gl_FragColor = vec4(0.2, 0.2, 0.0, 0.0);
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));
      gl_FragColor.g = 1.0;
    }
  </script>

  <script src="lightgl.js"></script>
  <script src="cubemap.js"></script>
  <script src="renderer.js"></script>
  <script src="water.js"></script>
  <script src="main.js"></script>
  <style type="text/css">
    body { font: 13px/140% Arial, sans-serif; background: #d0d8e0; color: #333; overflow: hidden; }
    a { color: inherit; cursor: pointer; }
    img { display: none; }
    ul { padding: 0 0 0 20px; }
    h1 { font: bold 30px/30px Georgia; text-align: center; }
    h2 { font: bold 17px/17px Georgia; padding-top: 10px; }
    small { display: block; font-size: 11px; line-height: 15px; }
    canvas { position: absolute; top: 0; left: 0; }
    #loading { position: absolute; left: 0; top: 50%; right: 300px; text-align: center; margin-top: -8px; }
    @media (max-width: 600px) {
      small { font-size: 8px; line-height: 10px; }
    }
  </style>
</head><body>
  <div id="loading">Loading...</div>
  <button id="randBtn">Random Drops: On</button>
  <img id="tiles">
  <img id="xneg">
  <img id="xpos">
  <img id="ypos">
  <img id="zneg">
  <img id="zpos">
  <script>
    (function(){
      function solidDataURL(w,h, r,g,b,a){
        var c=document.createElement('canvas'); c.width=w; c.height=h;
        var ctx=c.getContext('2d');
        ctx.fillStyle='rgba('+r+','+g+','+b+','+(a==null?1:a)+')';
        ctx.fillRect(0,0,w,h);
        return c.toDataURL('image/png');
      }
      // 더 연한 회색
      var lightGray = solidDataURL(512,512, 240,240,240,1);
      var ids=['tiles','xneg','xpos','ypos','zneg','zpos'];
      ids.forEach(function(id){ var img=document.getElementById(id); if(img) img.src=lightGray; });
    })();
  </script>
  <style>
    #randBtn {
      position: absolute; top: 16px; left: 16px; z-index: 10;
      padding: 8px 12px; border: 0; border-radius: 8px;
      background: linear-gradient(180deg,#ffffff,#e6e6e6);
      color: #333; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      cursor: pointer;
    }
    #randBtn.off { background: linear-gradient(180deg,#f6f6f6,#dddddd); color:#777; }
    #randBtn:active { transform: translateY(1px); }
  </style>
</body></html>
