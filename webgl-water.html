<!--
WebGL Water
https://madebyevan.com/webgl-water/

Copyright 2011 Evan Wallace
Released under the MIT license
-->

<!DOCTYPE html>
<html><head>
  <meta charset="utf8">
  <title>WebGL Water</title>
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
  
  <!-- Shaders -->
  <!-- Water simulation shaders -->
  <script id="water-vertex" type="x-shader/x-vertex">
    varying vec2 coord;
    void main() {
      coord = gl_Vertex.xy * 0.5 + 0.5;
      gl_Position = vec4(gl_Vertex.xyz, 1.0);
    }
  </script>
  
  <script id="water-drop-fragment" type="x-shader/x-fragment">
    const float PI = 3.141592653589793;
    uniform sampler2D texture;
    uniform vec2 center;
    uniform float radius;
    uniform float strength;
    varying vec2 coord;
    void main() {
      vec4 info = texture2D(texture, coord);
      float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);
      drop = 0.5 - cos(drop * PI) * 0.5;
      info.r += drop * strength;
      gl_FragColor = info;
    }
  </script>
  
  <script id="water-update-fragment" type="x-shader/x-fragment">
    uniform sampler2D texture;
    uniform vec2 delta;
    varying vec2 coord;
    void main() {
      vec4 info = texture2D(texture, coord);
      vec2 dx = vec2(delta.x, 0.0);
      vec2 dy = vec2(0.0, delta.y);
      float average = (
        texture2D(texture, coord - dx).r +
        texture2D(texture, coord - dy).r +
        texture2D(texture, coord + dx).r +
        texture2D(texture, coord + dy).r
      ) * 0.25;
      info.g += (average - info.r) * 1.0;
      info.g *= 0.995;
      info.r += info.g;
      gl_FragColor = info;
    }
  </script>
  
  <script id="water-normal-fragment" type="x-shader/x-fragment">
    uniform sampler2D texture;
    uniform vec2 delta;
    varying vec2 coord;
    void main() {
      vec4 info = texture2D(texture, coord);
      vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);
      vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);
      info.ba = normalize(cross(dy, dx)).xz;
      gl_FragColor = info;
    }
  </script>
  
  <script id="water-sphere-fragment" type="x-shader/x-fragment">
    uniform sampler2D texture;
    uniform vec3 oldCenter;
    uniform vec3 newCenter;
    uniform float radius;
    varying vec2 coord;
    
    float volumeInSphere(vec3 center) {
      vec3 toCenter = vec3(coord.x * 2.0 - 1.0, 0.0, coord.y * 2.0 - 1.0) - center;
      float t = length(toCenter) / radius;
      float dy = exp(-pow(t * 1.5, 6.0));
      float ymin = min(0.0, center.y - dy);
      float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);
      return (ymax - ymin) * 0.1;
    }
    
    void main() {
      vec4 info = texture2D(texture, coord);
      info.r += volumeInSphere(oldCenter);
      info.r -= volumeInSphere(newCenter);
      gl_FragColor = info;
    }
  </script>
  
  <!-- Helper functions for rendering -->
  <script id="helper-functions" type="x-shader/x-fragment">
    const float IOR_AIR = 1.0;
    const float IOR_WATER = 1.333;
    // 더 투명한 물 색상 (1에 가까울수록 투명)
    const vec3 abovewaterColor = vec3(0.75, 0.95, 1.0);
    const vec3 underwaterColor = vec3(0.8, 0.95, 1.0);
    const float poolHeight = 1.0;
    uniform vec3 light;
    uniform vec3 sphereCenter;
    uniform float sphereRadius;
    uniform sampler2D tiles;
    uniform sampler2D causticTex;
    uniform sampler2D water;
    
    vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
      vec3 tMin = (cubeMin - origin) / ray;
      vec3 tMax = (cubeMax - origin) / ray;
      vec3 t1 = min(tMin, tMax);
      vec3 t2 = max(tMin, tMax);
      float tNear = max(max(t1.x, t1.y), t1.z);
      float tFar = min(min(t2.x, t2.y), t2.z);
      return vec2(tNear, tFar);
    }
    
    float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {
      vec3 toSphere = origin - sphereCenter;
      float a = dot(ray, ray);
      float b = 2.0 * dot(toSphere, ray);
      float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;
      float discriminant = b*b - 4.0*a*c;
      if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.0) return t;
      }
      return 1.0e6;
    }
    
    vec3 getSphereColor(vec3 point) {
      vec3 color = vec3(0.5);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);
      color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);
      vec3 sphereNormal = (point - sphereCenter) / sphereRadius;
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;
      vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
      if (point.y < info.r) {
        vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
        diffuse *= caustic.r * 4.0;
      }
      color += diffuse;
      return color;
    }
    
    vec3 getWallColor(vec3 point) {
      float scale = 0.5;
      vec3 wallColor;
      vec3 normal;
      if (abs(point.x) > 0.999) {
        wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;
        normal = vec3(-point.x, 0.0, 0.0);
      } else if (abs(point.z) > 0.999) {
        wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;
        normal = vec3(0.0, 0.0, -point.z);
      } else {
        wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;
        normal = vec3(0.0, 1.0, 0.0);
      }
      scale /= length(point);
      scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0);
      vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      float diffuse = max(0.0, dot(refractedLight, normal));
      vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
      if (point.y < info.r) {
        vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
        scale += diffuse * caustic.r * 0.8 * caustic.g;
      } else {
        vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));
        scale += diffuse * 0.5;
      }
      return wallColor * scale;
    }
  </script>
  
  <!-- Water surface rendering shaders -->
  <script id="water-surface-vertex" type="x-shader/x-vertex">
    uniform sampler2D water;
    varying vec3 position;
    void main() {
      vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);
      position = gl_Vertex.xzy;
      position.y += info.r;
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);
    }
  </script>
  
  <script id="water-surface-abovewater-fragment" type="x-shader/x-fragment">
    uniform vec3 eye;
    varying vec3 position;
    uniform samplerCube sky;
    
    vec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
      vec3 color;
      float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);
      if (q < 1.0e6) {
        color = getSphereColor(origin + ray * q);
      } else if (ray.y < 0.0) {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        color = getWallColor(origin + ray * t.y);
      } else {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        vec3 hit = origin + ray * t.y;
        if (hit.y < 2.0 / 12.0) {
          color = getWallColor(hit);
        } else {
          color = textureCube(sky, ray).rgb;
          color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
        }
      }
      // 물 색상을 더 투명하게 적용
      if (ray.y < 0.0) color = mix(color, color * waterColor, 0.3);
      return color;
    }
    
    void main() {
      vec2 coord = position.xz * 0.5 + 0.5;
      vec4 info = texture2D(water, coord);
      for (int i = 0; i < 5; i++) {
        coord += info.ba * 0.005;
        info = texture2D(water, coord);
      }
      vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
      vec3 incomingRay = normalize(position - eye);
      vec3 reflectedRay = reflect(incomingRay, normal);
      vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);
      float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));
      vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, abovewaterColor);
      vec3 refractedColor = getSurfaceRayColor(position, refractedRay, abovewaterColor);
      gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);
    }
  </script>
  
  <script id="water-surface-underwater-fragment" type="x-shader/x-fragment">
    uniform vec3 eye;
    varying vec3 position;
    uniform samplerCube sky;
    
    vec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
      vec3 color;
      float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);
      if (q < 1.0e6) {
        color = getSphereColor(origin + ray * q);
      } else if (ray.y < 0.0) {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        color = getWallColor(origin + ray * t.y);
      } else {
        vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        vec3 hit = origin + ray * t.y;
        if (hit.y < 2.0 / 12.0) {
          color = getWallColor(hit);
        } else {
          color = textureCube(sky, ray).rgb;
          color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
        }
      }
      // 물 색상을 더 투명하게 적용
      if (ray.y < 0.0) color = mix(color, color * waterColor, 0.3);
      return color;
    }
    
    void main() {
      vec2 coord = position.xz * 0.5 + 0.5;
      vec4 info = texture2D(water, coord);
      for (int i = 0; i < 5; i++) {
        coord += info.ba * 0.005;
        info = texture2D(water, coord);
      }
      vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
      vec3 incomingRay = normalize(position - eye);
      normal = -normal;
      vec3 reflectedRay = reflect(incomingRay, normal);
      vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);
      float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));
      vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, underwaterColor);
      vec3 refractedColor = getSurfaceRayColor(position, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);
      gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);
    }
  </script>
  
  <!-- Sphere rendering shaders -->
  <script id="sphere-vertex" type="x-shader/x-vertex">
    varying vec3 position;
    void main() {
      position = sphereCenter + gl_Vertex.xyz * sphereRadius;
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);
    }
  </script>
  
  <script id="sphere-fragment" type="x-shader/x-fragment">
    varying vec3 position;
    void main() {
      gl_FragColor = vec4(getSphereColor(position), 1.0);
      vec4 info = texture2D(water, position.xz * 0.5 + 0.5);
      if (position.y < info.r) {
        gl_FragColor.rgb *= underwaterColor * 1.2;
      }
    }
  </script>
  
  <!-- Cube (pool walls) rendering shaders -->
  <script id="cube-vertex" type="x-shader/x-vertex">
    varying vec3 position;
    void main() {
      position = gl_Vertex.xyz;
      position.y = ((1.0 - position.y) * (7.0 / 12.0) - 1.0) * poolHeight;
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);
    }
  </script>
  
  <script id="cube-fragment" type="x-shader/x-fragment">
    varying vec3 position;
    void main() {
      gl_FragColor = vec4(getWallColor(position), 1.0);
      vec4 info = texture2D(water, position.xz * 0.5 + 0.5);
      if (position.y < info.r) {
        gl_FragColor.rgb *= underwaterColor * 1.2;
      }
    }
  </script>
  
  <!-- Caustics rendering shaders -->
  <script id="caustics-vertex" type="x-shader/x-vertex">
    varying vec3 oldPos;
    varying vec3 newPos;
    varying vec3 ray;
    
    vec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {
      vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      origin += ray * tcube.y;
      float tplane = (-origin.y - 1.0) / refractedLight.y;
      return origin + refractedLight * tplane;
    }
    
    void main() {
      vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);
      info.ba *= 0.5;
      vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      ray = refract(-light, normal, IOR_AIR / IOR_WATER);
      oldPos = project(gl_Vertex.xzy, refractedLight, refractedLight);
      newPos = project(gl_Vertex.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);
      gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);
    }
  </script>
  
  <script id="caustics-fragment" type="x-shader/x-fragment">
    varying vec3 oldPos;
    varying vec3 newPos;
    varying vec3 ray;
    
    void main() {
      gl_FragColor = vec4(0.08, 0.08, 0.0, 0.0);
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      vec3 dir = (sphereCenter - newPos) / sphereRadius;
      vec3 area = cross(dir, refractedLight);
      float shadow = dot(area, area);
      float dist = dot(dir, -refractedLight);
      shadow = 1.0 + (shadow - 1.0) / (0.05 + dist * 0.025);
      shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);
      shadow = mix(1.0, shadow, clamp(dist * 2.0, 0.0, 1.0));
      gl_FragColor.g = shadow;
      vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));
    }
  </script>
  
  <script id="caustics-fragment-derivatives" type="x-shader/x-fragment">
    #extension GL_OES_standard_derivatives : enable
    varying vec3 oldPos;
    varying vec3 newPos;
    varying vec3 ray;
    
    void main() {
      float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));
      float newArea = length(dFdx(newPos)) * length(dFdy(newPos));
      gl_FragColor = vec4(oldArea / newArea * 0.08, 1.0, 0.0, 0.0);
      vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
      vec3 dir = (sphereCenter - newPos) / sphereRadius;
      vec3 area = cross(dir, refractedLight);
      float shadow = dot(area, area);
      float dist = dot(dir, -refractedLight);
      shadow = 1.0 + (shadow - 1.0) / (0.05 + dist * 0.025);
      shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);
      shadow = mix(1.0, shadow, clamp(dist * 2.0, 0.0, 1.0));
      gl_FragColor.g = shadow;
      vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
      gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));
    }
  </script>
  
  <script src="OES_texture_float_linear-polyfill.js"></script>
  <script src="lightgl.js"></script>
  <script src="cubemap.js"></script>
  <script src="renderer.js"></script>
  <script src="water.js"></script>
  <script src="main.js"></script>
  <style type="text/css">
    body { font: 13px/140% Arial, sans-serif; background: #d0d8e0; color: #333; overflow: hidden; }
    a { color: inherit; cursor: pointer; }
    img { display: none; }
    ul { padding: 0 0 0 20px; }
    h1 { font: bold 30px/30px Georgia; text-align: center; }
    h2 { font: bold 17px/17px Georgia; padding-top: 10px; }
    small { display: block; font-size: 11px; line-height: 15px; }
    canvas { position: absolute; top: 0; left: 0; }
    #help { position: absolute; top: 0; right: 0; bottom: 0; width: 280px; padding-right: 20px; overflow: auto; }
    #loading { position: absolute; left: 0; top: 50%; right: 300px; text-align: center; margin-top: -8px; }
    @media (max-width: 600px) {
      small { font-size: 8px; line-height: 10px; }
      #help { width: 100px; font-size: 10px; line-height: 12px; }
    }
  </style>
</head><body>
  <div id="loading">Loading...</div>
  <img id="tiles" style="display:none;">
  <img id="xneg" style="display:none;">
  <img id="xpos" style="display:none;">
  <img id="ypos" style="display:none;">
  <img id="zneg" style="display:none;">
  <img id="zpos" style="display:none;">
  <script>
    (function(){
      function solidDataURL(w,h, r,g,b,a){
        var c=document.createElement('canvas'); c.width=w; c.height=h;
        var ctx=c.getContext('2d');
        ctx.fillStyle='rgba('+r+','+g+','+b+','+(a==null?1:a)+')';
        ctx.fillRect(0,0,w,h);
        return c.toDataURL('image/png');
      }
      function gridDataURL(size, cells){
        var c=document.createElement('canvas'); c.width=size; c.height=size;
        var ctx=c.getContext('2d');
        // 연한 회색 타일 (거의 흰색에 가깝게)
        ctx.fillStyle='#f5f5f5';
        ctx.fillRect(0,0,size,size);
        var step=size/cells;
        // 매우 연한 회색 선
        ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=4; ctx.strokeRect(2,2,size-4,size-4);
        ctx.lineWidth=1; ctx.strokeStyle='#e8e8e8';
        ctx.beginPath();
        for(var i=1;i<cells;i++){
          var p=i*step;
          ctx.moveTo(p,0); ctx.lineTo(p,size);
          ctx.moveTo(0,p); ctx.lineTo(size,p);
        }
        ctx.stroke();
        return c.toDataURL('image/png');
      }
      var sky = solidDataURL(512,512, 170,210,255,1);
      var ids=['xneg','xpos','ypos','zneg','zpos'];
      ids.forEach(function(id){ 
        var img=document.getElementById(id); 
        if(img) img.src=sky; 
      });
      var tiles=document.getElementById('tiles');
      if(tiles) tiles.src = gridDataURL(1024, 24);
    })();
  </script>
</body></html>
